name: "Cache Docker Images"
description: "Intelligent Docker image caching to avoid rate limiting issues from Docker registries"

inputs:
  cache-key:
    description: "Base cache key for the Docker images"
    required: false
    default: "docker-images"
  images:
    description: "Comma-separated list of Docker images to cache"
    required: true
  restore-only:
    description: "Only restore cache, don't save new cache"
    required: false
    default: "false"
  check-updates:
    description: "Check for AutoKitteh updates and pull newer versions"
    required: false
    default: "false"

outputs:
  cache-hit:
    description: "Whether the cache was restored (true or false)"
    value: ${{ steps.cache-restore.outputs.cache-hit }}
  images-loaded:
    description: "Comma-separated list of images loaded from cache"
    value: ${{ steps.process-images.outputs.images-loaded }}
  updated-images:
    description: "Comma-separated list of AutoKitteh images that were updated"
    value: ${{ steps.check-autokitteh-version.outputs.updated-images }}

runs:
  using: "composite"
  steps:
    - name: üîß Generate cache key
      id: cache-key
      shell: bash
      run: |
        # Create a hash of the image list for cache key uniqueness
        IMAGES_HASH=$(echo "${{ inputs.images }}" | sha256sum | cut -d' ' -f1 | head -c 8)
        CACHE_KEY="${{ inputs.cache-key }}-${IMAGES_HASH}-${{ runner.os }}"
        echo "cache-key=$CACHE_KEY" >> "$GITHUB_OUTPUT"
        echo "Generated cache key: $CACHE_KEY"

    - name: üîÑ Restore Docker images from cache
      id: cache-restore
      uses: actions/cache/restore@v4
      with:
        path: /tmp/docker-cache
        key: ${{ steps.cache-key.outputs.cache-key }}

    - name: üì¶ Process cached images
      id: process-images
      shell: bash
      run: |
        # Convert comma-separated images to array
        IFS=',' read -ra IMAGES <<< "${{ inputs.images }}"
        LOADED_IMAGES=""
        MISSING_IMAGES=""
        
        echo "Processing images: ${{ inputs.images }}"
        
        if [ "${{ steps.cache-restore.outputs.cache-hit }}" == "true" ]; then
          echo "‚úÖ Cache hit! Loading images from cache..."
          
          # Load cached images
          for image in "${IMAGES[@]}"; do
            image=$(echo "$image" | xargs) # trim whitespace
            cache_file="/tmp/docker-cache/${image//[\/:]/_}.tar"
            
            if [ -f "$cache_file" ]; then
              echo "Loading $image from cache..."
              if docker load < "$cache_file"; then
                if [ -n "$LOADED_IMAGES" ]; then
                  LOADED_IMAGES="$LOADED_IMAGES,$image"
                else
                  LOADED_IMAGES="$image"
                fi
                echo "‚úÖ Loaded $image from cache"
              else
                echo "‚ùå Failed to load $image from cache, will pull fresh"
                if [ -n "$MISSING_IMAGES" ]; then
                  MISSING_IMAGES="$MISSING_IMAGES,$image"
                else
                  MISSING_IMAGES="$image"
                fi
              fi
            else
              echo "‚ö†Ô∏è Cache file not found for $image, will pull fresh"
              if [ -n "$MISSING_IMAGES" ]; then
                MISSING_IMAGES="$MISSING_IMAGES,$image"
              else
                MISSING_IMAGES="$image"
              fi
            fi
          done
        else
          echo "‚ùå Cache miss! All images need to be pulled"
          MISSING_IMAGES="${{ inputs.images }}"
        fi
        
        echo "images-loaded=$LOADED_IMAGES" >> "$GITHUB_OUTPUT"
        echo "missing-images=$MISSING_IMAGES" >> "$GITHUB_OUTPUT"
        
        echo "Images loaded from cache: $LOADED_IMAGES"
        echo "Images to pull: $MISSING_IMAGES"

    - name: üê≥ Pull missing Docker images
      if: steps.process-images.outputs.missing-images != ''
      shell: bash
      run: |
        IFS=',' read -ra MISSING <<< "${{ steps.process-images.outputs.missing-images }}"
        
        echo "Pulling missing images..."
        for image in "${MISSING[@]}"; do
          image=$(echo "$image" | xargs) # trim whitespace
          if [ -n "$image" ]; then
            echo "Pulling $image..."
            
            # Retry logic for rate limiting
            for attempt in 1 2 3; do
              if docker pull "$image"; then
                echo "‚úÖ Successfully pulled $image"
                break
              else
                echo "‚ùå Failed to pull $image (attempt $attempt/3)"
                if [ $attempt -eq 3 ]; then
                  echo "‚ùå Failed to pull $image after 3 attempts"
                  exit 1
                fi
                
                # Wait with exponential backoff
                wait_time=$((attempt * 30))
                echo "‚è≥ Waiting ${wait_time}s before retry..."
                sleep $wait_time
              fi
            done
          fi
        done

    - name: üíæ Save images to cache
      if: inputs.restore-only != 'true' && steps.process-images.outputs.missing-images != ''
      shell: bash
      run: |
        echo "Saving images to cache..."
        mkdir -p /tmp/docker-cache
        
        IFS=',' read -ra ALL_IMAGES <<< "${{ inputs.images }}"
        
        for image in "${ALL_IMAGES[@]}"; do
          image=$(echo "$image" | xargs) # trim whitespace
          if [ -n "$image" ]; then
            cache_file="/tmp/docker-cache/${image//[\/:]/_}.tar"
            
            # Only save if not already cached or if we just pulled it
            if [ ! -f "$cache_file" ] || [[ "${{ steps.process-images.outputs.missing-images }}" == *"$image"* ]]; then
              echo "Saving $image to cache..."
              if docker save "$image" > "$cache_file"; then
                echo "‚úÖ Saved $image to cache"
              else
                echo "‚ùå Failed to save $image to cache"
                rm -f "$cache_file" # Remove partial file
              fi
            else
              echo "‚è≠Ô∏è $image already cached, skipping"
            fi
          fi
        done

    - name: üóÇÔ∏è Update cache
      if: inputs.restore-only != 'true'
      uses: actions/cache/save@v4
      with:
        path: /tmp/docker-cache
        key: ${{ steps.cache-key.outputs.cache-key }}

    - name: üìä Cache summary
      shell: bash
      run: |
        echo "üóÇÔ∏è Docker Image Cache Summary"
        echo "=============================="
        echo "Cache key: ${{ steps.cache-key.outputs.cache-key }}"
        echo "Cache hit: ${{ steps.cache-restore.outputs.cache-hit }}"
        echo "Images loaded from cache: ${{ steps.process-images.outputs.images-loaded }}"
        echo "Images pulled fresh: ${{ steps.process-images.outputs.missing-images }}"
        echo "Restore only mode: ${{ inputs.restore-only }}"
        
        # Show cache directory size if it exists
        if [ -d "/tmp/docker-cache" ]; then
          echo "Cache directory size: $(du -sh /tmp/docker-cache | cut -f1)"
          echo "Cached files:"
          ls -la /tmp/docker-cache/ || true
        fi

    - name: üîç Check AutoKitteh version and update if needed
      if: inputs.check-updates == 'true'
      id: check-autokitteh-version
      shell: bash
      run: |
        echo "üîç Checking for AutoKitteh updates..."
        
        # Function to extract version from image tag
        get_image_version() {
          local image="$1"
          if [[ "$image" == *"autokitteh"* ]]; then
            # Extract version from image tag (e.g., "public.ecr.aws/autokitteh/server:v1.2.3" -> "v1.2.3")
            echo "$image" | sed 's/.*://' | sed 's/^v//'
          fi
        }
        
        # Function to compare versions (returns 0 if v1 >= v2, 1 if v1 < v2)
        version_compare() {
          local v1="$1"
          local v2="$2"
          
          # Remove 'v' prefix if present
          v1=$(echo "$v1" | sed 's/^v//')
          v2=$(echo "$v2" | sed 's/^v//')
          
          # Use sort -V for version comparison
          if [ "$(printf '%s\n%s' "$v1" "$v2" | sort -V | head -n1)" = "$v2" ]; then
            return 0  # v1 >= v2
          else
            return 1  # v1 < v2
          fi
        }
        
        # Check each image for AutoKitteh updates
        IFS=',' read -ra ALL_IMAGES <<< "${{ inputs.images }}"
        UPDATED_IMAGES=""
        
        for image in "${ALL_IMAGES[@]}"; do
          image=$(echo "$image" | xargs) # trim whitespace
          
          if [[ "$image" == *"autokitteh"* ]]; then
            echo "üì¶ Checking AutoKitteh image: $image"
            
            # Get current image version
            CURRENT_VERSION=$(get_image_version "$image")
            
            if [ -z "$CURRENT_VERSION" ] || [ "$CURRENT_VERSION" = "latest" ]; then
              echo "‚ö†Ô∏è Image uses 'latest' tag or version not detectable, checking for updates anyway..."
              SHOULD_UPDATE=true
            else
              echo "üìã Current version: $CURRENT_VERSION"
              
              # Get latest release from GitHub API
              echo "üåê Fetching latest release from GitHub..."
              LATEST_RELEASE=$(curl -s "https://api.github.com/repos/autokitteh/autokitteh/releases/latest" | grep '"tag_name"' | cut -d'"' -f4)
              
              if [ -z "$LATEST_RELEASE" ]; then
                echo "‚ùå Failed to fetch latest release information"
                continue
              fi
              
              echo "üÜï Latest release: $LATEST_RELEASE"
              
              # Compare versions
              if version_compare "$CURRENT_VERSION" "$LATEST_RELEASE"; then
                echo "‚úÖ Current version ($CURRENT_VERSION) is up to date"
                SHOULD_UPDATE=false
              else
                echo "üîÑ New version available: $LATEST_RELEASE (current: $CURRENT_VERSION)"
                SHOULD_UPDATE=true
              fi
            fi
            
            if [ "$SHOULD_UPDATE" = true ]; then
              echo "‚¨áÔ∏è Pulling updated AutoKitteh image..."
              
              # Construct new image name with latest version
              if [ -n "$LATEST_RELEASE" ] && [ "$LATEST_RELEASE" != "latest" ]; then
                # Replace version in image name
                NEW_IMAGE=$(echo "$image" | sed "s/:.*/:$LATEST_RELEASE/")
                echo "üè∑Ô∏è New image: $NEW_IMAGE"
              else
                NEW_IMAGE="$image"
              fi
              
              # Pull the new image
              for attempt in 1 2 3; do
                if docker pull "$NEW_IMAGE"; then
                  echo "‚úÖ Successfully pulled updated image: $NEW_IMAGE"
                  
                  # Update cache with new image
                  cache_file="/tmp/docker-cache/${NEW_IMAGE//[\/:]/_}.tar"
                  mkdir -p /tmp/docker-cache
                  
                  if docker save "$NEW_IMAGE" > "$cache_file"; then
                    echo "üíæ Updated cache with new image"
                    if [ -n "$UPDATED_IMAGES" ]; then
                      UPDATED_IMAGES="$UPDATED_IMAGES,$NEW_IMAGE"
                    else
                      UPDATED_IMAGES="$NEW_IMAGE"
                    fi
                  else
                    echo "‚ö†Ô∏è Failed to save updated image to cache"
                  fi
                  break
                else
                  echo "‚ùå Failed to pull $NEW_IMAGE (attempt $attempt/3)"
                  if [ $attempt -eq 3 ]; then
                    echo "‚ùå Failed to pull updated image after 3 attempts"
                  else
                    wait_time=$((attempt * 30))
                    echo "‚è≥ Waiting ${wait_time}s before retry..."
                    sleep $wait_time
                  fi
                fi
              done
            fi
          else
            echo "‚è≠Ô∏è Skipping non-AutoKitteh image: $image"
          fi
        done
        
        if [ -n "$UPDATED_IMAGES" ]; then
          echo ""
          echo "üéâ Updated images: $UPDATED_IMAGES"
          echo "updated-images=$UPDATED_IMAGES" >> "$GITHUB_OUTPUT"
        else
          echo ""
          echo "‚ÑπÔ∏è No AutoKitteh images needed updating"
          echo "updated-images=" >> "$GITHUB_OUTPUT"
        fi